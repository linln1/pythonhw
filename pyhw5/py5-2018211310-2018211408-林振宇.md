# Python程序设计#5作业

截止时间：2020年11月23日23:59:59

## 作业题目

在作业#4的基础上实现remoteProxy对每个用户进行单独流控

SQLite3数据库的每个用户的账号信息中增加带宽信息（用户名、密码、带宽）

带宽的单位为BPS（Bytes / Second，字节每秒），该带宽为某个用户的所有连接的转发数据总和带宽。

此次作业需要在【代码说明】中陈述流控的技术方案和实现机制。

## 作业内容

程序源代码嵌入下方的code block中。

```python
import asyncio

if __name__ == '__main__':
    pass
```

## 代码说明

首先实现了令牌桶类
令牌桶类有两个函数，
一个input函数接受来自外部的数据流，其中，如果当前到来的数据会溢出桶，就让它溢出，在加入令牌桶的时候，需要请求锁，桶内数据修改完之后释放锁。
另一个函数output将数据以恒定速率发送到外部，如果数据不足BPS,就发送剩下的所有数据，在令牌桶向外泄露数据的时候，也需要锁，数据流出后，就不会再存在于桶内，然后释放锁。

其中对于远程服务器认证部分和转发数据部分做了修改
对于初始化数据库，增加了BANDWITH属性，用来记录每个用户的流速。
当有用户通过命令试图连接远程服务器的时候，首先进行用户名密码登录验证，然后检查当前该用户的带宽，
如果超过了限制，就拒绝该用户的连接。返回服务器繁忙的信息。

对于每个用户，有两个令牌桶实例，一个接受来自本地代理发送的数据，然后以限定的流速发送给远方服务器，
另一个接受来自服务器的响应，以固定的速率返回给用户。
这个利用字典来实现，一个username 对应 两个实例uBucket和sBucket。
remote_proxy所有收到的数据都要经过令牌桶，利用aioRead来实现，
其中向aioRead函数传递两个参数 user bucket
当传递了user的时候，可以通过字典查找user对应的uBucket，然后将数据读入uBucket
当传递了bucket的时候，就有可能是uBucket或者是sBucket，也就是有可能收到的是来自服务器的响应信息，也有可能是来自local_proxy的请求信息

然后四个函数，分别实现接收local_proxy请求，向远程server发送请求，接受server响应，向local_proxy返回响应，这里面都要经过桶
这四个函数，在数据库登录认证成功后，被当作并发任务启动

其中向外发送数据需要计算BPS，Bytes Per Second， 也就是控制流量小于传进来的参数lim，
就是在发送之前开始计时，等待aioWrite(w, len=args.lim);然后sleep(1-发送数据经过的时间)，这样可以保证
发送数据速率不会超过限制，同时向数据库中写入BANDWTIH=args.lim
如果当前桶内数据小于args.lim,记当前数据长度是len, 那么当前发送速率就是len,也就可以允许同用户多点登录发送请求


